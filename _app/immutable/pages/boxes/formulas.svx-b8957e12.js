import{S as V,i as F,s as G,D as w,x as D,y as H,z as R,A as T,B as E,r as q,p as C,C as I,R as B,e as f,t as v,k as y,c as d,a as _,h as $,d as c,m as k,g,Q as u,b as x,n as L}from"../../chunks/index-0cc79b3e.js";import{B as j}from"../../chunks/Box-7a4e1585.js";import{R as z}from"../../chunks/Result-79dbd34f.js";function A(h){let s,e,o,n,a,l,r,i,t='<code class="language-ts"><span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></code>';return{c(){s=f("div"),e=f("h2"),o=v("Perimeter"),n=y(),a=f("p"),l=v("Perimeter of a rectangle"),r=y(),i=f("pre"),this.h()},l(p){s=d(p,"DIV",{slot:!0});var m=_(s);e=d(m,"H2",{});var b=_(e);o=$(b,"Perimeter"),b.forEach(c),n=k(m),a=d(m,"P",{});var P=_(a);l=$(P,"Perimeter of a rectangle"),P.forEach(c),r=k(m),i=d(m,"PRE",{class:!0});var S=_(i);S.forEach(c),m.forEach(c),this.h()},h(){x(i,"class","language-ts"),x(s,"slot","input")},m(p,m){g(p,s,m),u(s,e),u(e,o),u(s,n),u(s,a),u(a,l),u(s,r),u(s,i),i.innerHTML=t},p:L,d(p){p&&c(s)}}}function Q(h){let s,e,o=`<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>P</mi><mo>=</mo><mn>2</mn><mi>l</mi><mo>+</mo><mn>2</mn><mi>w</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\\begin{equation*}
P = 2l+2w
\\end{equation*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span></span></span></span></span></span>`;return{c(){s=f("div"),e=f("div"),this.h()},l(n){s=d(n,"DIV",{slot:!0});var a=_(s);e=d(a,"DIV",{class:!0});var l=_(e);l.forEach(c),a.forEach(c),this.h()},h(){x(e,"class","math math-display"),x(s,"slot","result")},m(n,a){g(n,s,a),u(s,e),e.innerHTML=o},p:L,d(n){n&&c(s)}}}function J(h){let s,e,o,n,a,l,r,i;return r=new z({props:{left:"",right:"",$$slots:{result:[Q],input:[A]},$$scope:{ctx:h}}}),{c(){s=f("p"),e=v("Below is a list of formulas for you convenience to use."),o=y(),n=f("h1"),a=v("Geometry"),l=y(),D(r.$$.fragment)},l(t){s=d(t,"P",{});var p=_(s);e=$(p,"Below is a list of formulas for you convenience to use."),p.forEach(c),o=k(t),n=d(t,"H1",{});var m=_(n);a=$(m,"Geometry"),m.forEach(c),l=k(t),H(r.$$.fragment,t)},m(t,p){g(t,s,p),u(s,e),g(t,o,p),g(t,n,p),u(n,a),g(t,l,p),R(r,t,p),i=!0},p(t,p){const m={};p&2&&(m.$$scope={dirty:p,ctx:t}),r.$set(m)},i(t){i||(q(r.$$.fragment,t),i=!0)},o(t){C(r.$$.fragment,t),i=!1},d(t){t&&c(s),t&&c(o),t&&c(n),t&&c(l),I(r,t)}}}function K(h){let s,e;const o=[h[0],M];let n={$$slots:{default:[J]},$$scope:{ctx:h}};for(let a=0;a<o.length;a+=1)n=w(n,o[a]);return s=new j({props:n}),{c(){D(s.$$.fragment)},l(a){H(s.$$.fragment,a)},m(a,l){R(s,a,l),e=!0},p(a,[l]){const r=l&1?T(o,[l&1&&E(a[0]),l&0&&E(M)]):{};l&2&&(r.$$scope={dirty:l,ctx:a}),s.$set(r)},i(a){e||(q(s.$$.fragment,a),e=!0)},o(a){C(s.$$.fragment,a),e=!1},d(a){I(s,a)}}}const M={title:"Formula Cheat Sheet",layout:"boxes"};function N(h,s,e){return h.$$set=o=>{e(0,s=w(w({},s),B(o)))},s=B(s),[s]}class X extends V{constructor(s){super(),F(this,s,N,K,G,{})}}export{X as default,M as metadata};
